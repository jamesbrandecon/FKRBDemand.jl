var documenterSearchIndex = {"docs":
[{"location":"api/#API-Documentation","page":"API","title":"API Documentation","text":"","category":"section"},{"location":"api/#FKRBDemand.define_problem","page":"API","title":"FKRBDemand.define_problem","text":"define_problem(; data, linear, nonlinear, \n    fixed_effects = [\"\"], train=[], \n    range = (-Inf, Inf), step = 0.1, \n    alpha = 0.0001)\n\nDefines the FKRB problem, which is just a container for the data and eventual results. \n\nArguments:\n\ndata: DataFrame containing the data.\nlinear: Vector of strings representing variables to be included in the utility function\nThis should match nonlinear – the API only includes both because it borrows from FRACDemand.jl\nnonlinear:  Vector of strings representing variables to be included in the utility function\nfixed_effects: Vector of strings representing fixed effects (default: empty).\ntrain: Vector of market_ids representing the hyperparameter turning data (default: empty).\nrange: Range of domain for random coefficients (default: (-Inf, Inf)).\nstep: Step size for the grid points (default: 0.1).\nalpha: Significance level for confidence intervals (default: 0.0001).\n\nReturns:\n\nFKRBProblem object containing the defined problem.\n\n\n\n\n\n","category":"function"},{"location":"api/#FKRBDemand.make_grid_points","page":"API","title":"FKRBDemand.make_grid_points","text":"make_grid_points(data, linear, nonlinear)\n\nGenerates a grid of points for evaluating the FKRB model. Currently a very simple implementation, though easy to  extend. \n\n# Arguments\n\ndata::DataFrame\nlinear::Vector{String}: A vector of variable names from data indicating the terms in the utility function.\nnonlinear::Vector{String}: A vector of variable names from data. Should match linear– will eventually collapse these into one input.\n\nOutput:\n\ngrid_points::Matrix{Float64}: A matrix of grid points for the linear/nonlinear variables. Each row corresponds to a grid point, and each column corresponds to a variable.\n\n\n\n\n\n","category":"function"},{"location":"api/#FKRBDemand.estimate!","page":"API","title":"FKRBDemand.estimate!","text":"estimate!(problem::FKRBProblem; \n    method = \"elasticnet\",\n    constraints = nothing,\n    silent = true,\n    gamma = 0.5, lambda = 0.0,\n    cross_validate = false, \n    folds = 5)\n\nEstimates the FKRB model using constrained elastic net. Problem is solved using Convex.jl, and estimated weights  are constrained to be nonnegative and sum to 1. Results are stored in problem.results.\n\nArguments:\n\nproblem::FKRBProblem: FKRB problem to be estimated.\nmethod::String: Method to use for estimation (default: \"elasticnet\").\nconstraints::Vector: Constraints to apply to the estimation (default: nothing).\nOptions: :nonnegativity, :proper_weights\nsilent::Bool: If true, suppresses printing of traces during optimization (default: true).\ngamma::Float64: Elastic net mixing parameter (default: 0.5).\nlambda::Float64: Regularization parameter (default: 0.0).\ncross_validate::Bool: If true, performs cross-validation to select the optimal penalty parameter (default: false).\nfolds::Int: Number of folds for cross-validation (default: 5).\n\nReturns:\n\nproblem: The FKRBProblem object with the estimated weights and other results.\n\n\n\n\n\n","category":"function"},{"location":"api/#FKRBDemand.subsample!","page":"API","title":"FKRBDemand.subsample!","text":"subsample!(problem::FKRBProblem)\n\nArguments\n\nproblem::FKRBProblem: FKRB problem (should be estimated first).\nn::Int = nothing: The number of samples to draw from the data. If nothing, a default value is used.\nn_samples::Int = 100: The number of bootstrap samples to generate.\nlambda::Float64 = 1e-6: The regularization strength parameter for the elastic net.\n\nChange to the problem object:\n\nproblem.inference_results: A list of raw bootstrap results.\nproblem.std: A vector of standard deviations for each weight parameter.\nproblem.results[\"boot_weights\"]: A matrix of weights, where each column corresponds to a subsample estimate.\n\n\n\n\n\n","category":"function"},{"location":"api/#FKRBDemand.bootstrap!","page":"API","title":"FKRBDemand.bootstrap!","text":"bootstrap!(problem::FKRBProblem; n_samples = 100, lambda = 1e-6, cross_validate = false)\n\nPerform standard bootstrapping on the given FKRBProblem to estimate the uncertainty of model parameters and derived quantities. This function modifies the problem object in place by adding bootstrap results to it.\n\nArguments\n\nproblem::FKRBProblem: FKRB problem (should be estimated first).\nn_samples::Int = 100: The number of bootstrap samples to generate.\nlambda::Float64 = 1e-6: The regularization strength parameter for the elastic net.\ncross_validate::Bool = false: If true, perform cross-validation to select the optimal penalty parameter.\n\nChange to the problem object:\n\nproblem.inference_results: A list of raw bootstrap results.\nproblem.std: A vector of standard deviations for each weight parameter.\nproblem.results[\"boot_weights\"]: A matrix of bootstrap weights, where each column corresponds to a bootstrap sample.\n\n\n\n\n\n","category":"function"},{"location":"api/#FKRBDemand.plot_coefficients","page":"API","title":"FKRBDemand.plot_coefficients","text":"plot_coefficients(\n    problem::FKRBProblem;\n    select_dims::Vector{String}=dim_names,\n    heatmap_kwargs   = (c = cgrad([:white, :lightblue, :blue]), alpha = 0.6),\n    marg_kwargs      = (c = :lightblue, alpha = 0.6),\n)\n\nCreate a pairs matrix of weighted marginal histograms (on the diagonal) and joint heatmaps (off–diagonal lower triangle), styled like an R “pairs()” summary.  You can select a subset of dimensions to plot via select_dims.\n\nArguments\n\nselect_dims::Vector{String}: subset of dim_names to include (default: all).\nheatmap_kwargs: NamedTuple of keyword args passed to heatmap().\nmarg_kwargs: NamedTuple of keyword args passed to histogram().\n\nReturns\n\nA Plots.jl plot object with an m×m grid, where m = length(select_dims).\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"First, we can simulate some data using the FRACDemand package. The following example simulates a dataset with 600 markets, each with either 10 or 20 products. The resulting data frame contains columns for product characteristics, prices, shares, demand instruments, market IDs, and product IDs. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Half of markets will have 10 products, half will have 20 products\n    # There will be 600 (300*2) markets in total\n    J1, J2, T = 10, 20, 300  \n\n    β = [-1.0 1.0] # mean random coefficients\n    variances = [0.3.^2 0.3^2] # variances of random coefficients\n    ρ = 0.9\n    covariance = ρ * preference_SDs[1] * preference_SDs[2]\n    Σ = [variances[1] covariance; covariance variances[2]]\n    \n    ξ_var = 0.3 # \n\n    # Use FRACDemand function to generate the data\n    df = FRACDemand.sim_logit_vary_J(J1, J2, T, B, β, Σ, ξ_var)\n    df[df.market_ids .>T,:product_ids] .+= J1 - 2 # this is correcting a bug -- necessary but will be fixed soon\n    \n    df = select(df, Not(:xi)) # remove simulated xi -- will be replaced in estimation\n\n    # Simulated data only has two demand instruments, but we are going to add \n    df[!,\"demand_instruments3\"] = df[!,\"demand_instruments1\"] .* df[!,\"demand_instruments2\"]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Then we \"define\" a problem using the FKRBDemand package. The define_problem function takes a data frame and a set of arguments that specify the problem to be solved. The arguments include the data frame, the linear and nonlinear variables, the training set, fixed effects, alpha, and step size. The function returns a FKRBProblem object that contains the problem definition.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Define the problem\n    problem = FKRBDemand.define_problem( \n        data = df, \n        linear = [\"prices\", \"x\"], # in FKRB, linear and nonlinear should be the same\n        nonlinear = [\"prices\", \"x\"], \n        train = [], # the set of market_ids to use for tuning regularization, mostly not yet useful\n        fixed_effects = [\"product_ids\"], # strings of column names in df to aborb in FRAC\n        alpha = 0.01, # FKRB grid will aim to cover (1-alpha*100)% of the distribution, based on FRACDemand estimates\n        step = 0.1 # step size for the FKRB grid\n    )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For estimation, the only required input is the problem object, though you can also manually control the regularization strength and how to constrain the weights. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Estimate the model\n    FKRBDemand.estimate!(problem, \n        method = \"elasticnet\", # only useful method implemented so far\n        constraints = [:nonnegativity, :proper_weights], # constraints on the weights\n        lambda = 1e-6) # regularization strength","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"There are a couple of plotting tools we can use. If you want to plot the joint distribution of random coefficients, you can use the plot_coefficients function.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Plot the coefficients\n    plot_coefficients(\n        problem;\n        select_dims = [\"prices\", \"x\"],\n        heatmap_kwargs   = (c = cgrad([:white, :lightblue, :blue]), alpha = 0.6),\n        marg_kwargs      = (c = :lightcoral, lw=2, alpha = 0.8, nbins=50)\n    )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We also store the CDF in the results field of the FKRBProblem object. This can be used to plot the CDF of the random coefficients, and easy transformations of this can be used to make custom plots of distributions. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Plot the CDF of the random coefficients\n    using Plots\n    cdf_dataframe = problem.results[\"cdf_dataframe\"]\n    # Dataframe in this case has three columns: \"prices\", \"x\", and \"values\"\n    # Values denotes the x-axis of the CDF, and each column denotes the CDF of the corresponding coefficient at that value\n    \n    # How to plot the CDF of price coefficients\n    plot(\n        cdf_dataframe.values, \n        cdf_dataframe.prices,\n        xlabel = \"Random Coefficient on Price\",\n        ylabel = \"Cumulative Probability\"\n    )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Finally, we can use the subsample! and bootstrap! functions to perform inference on the estimated coefficients. These functions take the FKRBProblem object as their only required argument, plus keyword arguments controlling how many times to repeat the estimation procedure and how large a subsample to use. After one of these functions are called, problem.std will contain the implied standard errors from the called approach.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Subsampling\n    FKRBDemand.subsample!(problem, n_samples=100, sample_size=0.8)\n    \n    # Bootstrapping\n    FKRBDemand.bootstrap!(problem, n_samples=100)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Currently, the use of the resulting bootstraps/subsamples is limited (e.g., I'm not yet passing the uncertainty through to price elasticities). One thing you can do is add the uncertainty to plot_coefficients by passing include_CI set to true. This will add the marginal distributions of the bootstrapped/subsampled coefficients to the plot. ","category":"page"},{"location":"#FKRBDemand.jl","page":"Home","title":"FKRBDemand.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Documentation)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package implements a simple version of the method introduced by Fox, Kim, Ryan, and Bajari (2009) (FKRB) for estimating random coefficient mixed logit demand models with market-level data. This approach allows us to estimate the distribution of consumer preferences nonparametrically and through a simple elastic net regression, thereby avoiding some of the convergence and speed issues with empirical estimation of random coefficient models. The package allows you to do the following with just a few lines of code: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Estimate a random coefficient logit model \nRun a bootstrap to get standard errors on the resulting model estimates (i.e., estimated weights) \nCalculate price elasticities at existing prices (easy todo: allow for counterfactual prices)\nPlot the (nonparametric) distribution of random coefficients","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, I've only implemented the FKRB approach for market-level data. My goal is to have an API which is familiar and relatively consistent across FRACDemand.jl, NPDemand.jl, and any other code I share for demand estimation, so that multiple packages can be tested quickly and eventually the packages can be merged together. PRs welcome – without them, updates will be very slow.  ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg; \n# FRAC has to be installed first\nPkg.add(\"FRACDemand\") \n# Install FKRBDemand from Github: \nPkg.add(url = \"https://github.com/jamesbrandecon/FKRBDemand.jl\")","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using FKRBDemand\n\ndf = ... # DataFrame with columns:\n# \"x\" (any number of product characteristics),\n# \"prices\",\n# \"shares\" (market shares),\n# \"demand_instruments0\" (any number of demand instruments)\n# \"market_ids\" \n# \"product_ids\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Estimation is then straightforward: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"problem = FKRBDemand.define_problem( \n        data = df, \n        linear = [\"prices\", \"x\"], # in FKRB, linear and nonlinear should be the same\n        nonlinear = [\"prices\", \"x\"], \n        train = [], # the set of market_ids to use for tuning regularization, mostly not yet useful\n        fixed_effects = [\"product_ids\"], # strings of column names in df to aborb in FRAC\n        alpha = 0.01, # FKRB grid will aim to cover (1-alpha*100)% of the distribution, based on FRACDemand estimates\n        step = 0.1 # step size for the FKRB grid\n        );\n\nFKRBDemand.estimate!(problem, \n    method = \"elasticnet\", # only useful method implemented so far\n    constraints = [:nonnegativity, :proper_weights], # constraints on the weights\n    lambda = 1e-6) # regularization strength","category":"page"},{"location":"#Price-endogeneity","page":"Home","title":"Price endogeneity","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The FKRB approach is best justified when all product characteristics are exogenous, but we are often interested in settings where that is not the case. The most general approach I've seen to handle endogeneity within this estimation approach is that from Meeker (2021), so I implemented a slightly modified version of his approach. I first estimate the model using FRACDemand.jl, using the same problem specifications that have been provided to FKRBDemand.jl, meaning that the regression FRACDemand.jl uses allows for random coefficients and instrument for prices. Then, I store the estimated demand shocks from that procedure and include them in the market-level demand function when estimating through FKRBDemand.jl. The intuition for this approach is that, by generating a good first estimate of unobserved demand shocks, we can then control for those shocks in the second stage. If we think of the regression errors in the FKRB second stage as measurement error, then this approach avoids the omitted variable bias (endogeneity) induced by running FKRBDemand.jl naively without correcting for endogenous prices. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you have an alternative preferred approach to estimating demand shocks, simply include a \"xi\" field in the data you provide to define_problem and these will be included in the utility function automatically. If you need fixed effects too, estimate them first via FRAC or a logit specification, add them together with your residuals xi, and include the sum as the field \"xi\" in problem.data.","category":"page"},{"location":"#Inference","page":"Home","title":"Inference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"I wasn't sure how to do inference here, but Meeker (2021) recommends subsampling/bootstrapping. I've implemented two simple helper functions for this purpose: bootstrap! and subsample!, which implement the inference approaches corresponding to the function names. Both functions take the FKRBProblem as the sole required argument, plus keyword arguments controlling how many times to repeat the estimation procedure and how large a subsample to use. After one of these functions are called, problem.std will contain the implied standard errors from the called approach. How to make the resulting standard errors easy to use is a work in progress, but problem.results[\"boot_weights\"] will contain the bootstrapped weights, which can be used to calculate confidence intervals on objects of interest.","category":"page"},{"location":"#Visualization","page":"Home","title":"Visualization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The best function for visualization is now plot_coefficients, which plots a grid of distributions. The diagonal of this grid shows kernel density estimates of the corresponding coefficients, while the off-diagonal elements show the estimated covariance between the coefficients. The function plot_coefficients takes a FKRBProblem object as its only required argument, though the heatmaps, densities, and the set of coefficients to plot can all be controlled through keyword arguments as shown below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"    plot_coefficients(\n        problem;\n        select_dims = [\"prices\", \"x\"],\n        heatmap_kwargs   = (c = cgrad([:white, :lightblue, :blue]), alpha = 0.6),\n        marg_kwargs      = (c = :lightcoral, lw=2, alpha = 0.8, nbins=50)\n    )","category":"page"}]
}
